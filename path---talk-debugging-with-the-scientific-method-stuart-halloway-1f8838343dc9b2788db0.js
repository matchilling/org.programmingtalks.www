webpackJsonp([99144201561507],{2948:function(e,t){e.exports={data:{talkJson:{description:"About the speaker: Stuart Halloway (@stuarthalloway) is a founder and President of Cognitect (formerly Relevance). He is a Clojure committer, and a developer of the Datomic database. Stuart has spoken at a variety of industry events, including Strange Loop, Clojure/conj, EuroClojure, ClojureWest, SpeakerConf, QCon, GOTO, OSCON, RailsConf, RubyConf, JavaOne, and NFJS. Stuart has written a number of books and technical articles. Of these, he is most proud of Programming Clojure.",meta:{duration:"PT49M9S"},presenter:{name:null},slug:"debugging-with-the-scientific-method-stuart-halloway",source:{id:"FihU5JxmnBg",provider:"youtube"},tag:["clojure","Debugging (Quotation Subject)","Scientific Method (Literature Subject)"],title:"Debugging with the Scientific Method - Stuart Halloway"},allTalkJson:{edges:[{node:{description:"The Clojure ecosystem, we're told, is made up of small, composable libraries. In practice, though, it's all too common to find that two libraries simply will not cleanly compose. This typically will lead to another library that does the same thing, but in a subtly different way. Sometimes this is warranted, but often it's not.\n\nThis talk will discuss the constraints and affordances that make a piece of code play nicely with other pieces of code. Attendees will learn how to write clean, reusable Clojure, drawing on the speaker's many past failures and few notable successes.\n\nThe first place I think of, when I try to tell someone about this quality, is a corner of an English country garden, where Zach Tellman grows against a wall.\n\nThe wall runs east to west; Zach grows flat against its southern side. The sun shines on him and as it warms the bricks behind Zach, the warm bricks themselves warms the peaches on him. It has a slightly dozy quality. Zach, carefully tied to grow flat against the wall; warming the bricks; the peaches growing in the sun; the wild grass growing around Zach's roots, in the angle where the earth and roots and wall all meet.",meta:{duration:"PT35M12S"},presenter:{name:null},source:{id:"3oQTSP4FngY",provider:"youtube"},slug:"zach-tellman-always-be-composing",tag:["clojure","abstraction","Functional Programming (Programming Language Paradigm)"],thumbnails:{default:{url:"https://i.ytimg.com/vi/3oQTSP4FngY/default.jpg",height:90,width:120}},title:"Zach Tellman - Always Be Composing"}},{node:{description:"Many of us have hazy memories of finite state machines from computer science theory classes in college. But finite state machines (FSMs) have real, practical value, and it is useful to know how to build and apply them in Clojure. For example, FSMs have long been popular to model game AIs and workflow rules, and FSMs provide the behind-the-scenes magic that powers Java's regexes and core.async's go blocks. In this talk, we'll look at two programming puzzles that, suprisingly, have very elegant solutions when looked at through the lens of FSMs, with code demonstrations using two different Clojure libraries for automata (automat and reduce-fsm), as well as loco, a Clojure constraint solver.\n\nAbout the speakers: Mark Engelberg has been an active member of the Clojure community ever since Clojure turned 1.0, and is the primary developer of math.combinatorics, math.numeric-tower, data.priority-map, ubergraph, and a co-developer of instaparse. By day, he teaches Scheme and Clojure to talented kids in the Seattle area; by night, he creates logic puzzles and games, using Clojure as his \"secret weapon\". His latest game is Code Master, a programming-themed puzzle game for kids, available exclusively at Target (and created with Clojure, of course!)\n\nAlex Engelberg was indoctrinated by his father in the ways of functional programming at a young age, and Clojure rapidly became his language of choice. He is happy to be using Clojure professionally as a software engineer at SecureOne in Seattle. Alex also enjoys contributing to open source; he is the primary developer of loco, and co-developer of instaparse.",meta:{duration:"PT38M4S"},presenter:{name:null},source:{id:"AEhULv4ruL4",provider:"youtube"},slug:"solving-problems-with-automata-mark-engelberg-and-alex-engelberg",tag:["clojure","automata","finite state machines","Automata Theory"],thumbnails:{default:{url:"https://i.ytimg.com/vi/AEhULv4ruL4/default.jpg",height:90,width:120}},title:"Solving Problems with Automata - Mark Engelberg & Alex Engelberg"}},{node:{description:"Build Your Own Lisp for Great Justice\n\nImplementing a toy Lisp interpreter is practically a rite of passage for the budding computer scientist. This hallowed tradition is described in detail in \"Lisp in Small Pieces,\" the seminal work on the making of Lisps, but everybody loves a tl;dr, so let's do the 40 minute executive summary.\n\nWe'll charge at high speed\nthrough the following topics, with Clojure code to follow along with as we go (because there's no better language for implementing a Lisp than another Lisp):\n\n* Parsing: turning text files into ASTs\n* Fundamental Lisp datatypes\n* McCarthy's elementary functions\n* Evaluating Lisp code\n* Lambdas and lexical scope\n* Your friend, the state monad\n* Beyond Lisp: pattern matching and type systems\n\nWhen we're done, you'll be ready to go forth and fill the world with Lisps of all shapes, colours and Greenspun violations for Great Justice. Also, it'll be good fun.\n\nSpeaker\nBodil Stokke (@bodil) is a compulsive conference speaker in the fields of functional programming and internets technologies, and is a co-organiser of three annual developer conferences in her home\ntown of Oslo, Norway, mostly because she's still learning how to stop. She is a prolific contributor to the Free Software community, primarily as a Clojure developer, and has recently taken up designing new programming languages as a hobby. In her spare time, she works as a web developer for Comoyo, which is like Hulu for non-Americans.",meta:{duration:"PT53M52S"},presenter:{name:null},source:{id:"DHubfS8E--o",provider:"youtube"},slug:"functional-programming-bodil-stokke",tag:["programming","lisp","geek","functional","clojure"],thumbnails:{default:{url:"https://i.ytimg.com/vi/DHubfS8E--o/default.jpg",height:90,width:120}},title:"Functional programming - Bodil Stokke"}},{node:{description:"Genetic programming harnesses the mechanisms of natural evolution, including mutation, recombination, and natural selection, to automatically synthesize computer programs. It has been applied to a wide range of problems spanning several areas of science, engineering, and the arts, in many cases equaling or exceeding human performance.\n\nGenetic programming's roots are in Lisp, making Clojure a natural choice for modern genetic programming research and development. In this talk I will show how a simple genetic programming system can be written in about 100 lines of Clojure code, how a mature genetic programming system (PushGP) implemented in Clojure can improve the state of the art in automatic programming, and how genetic programming can be incorporated into an artificial life environment implemented in Clojure and Quil.\n\nAbout the speaker: Lee Spector is a Professor of Computer Science in the School of Cognitive Science at Hampshire College in Amherst, Massachusetts, and an adjunct professor of Computer Science at the University of Massachusetts, Amherst. His areas of teaching and research include genetic and evolutionary computation, quantum computation, and a variety of intersections between computer science, cognitive science, evolutionary biology, and the arts. He is the Editor-in-Chief of the journal Genetic Programming and Evolvable Machines (published by Springer) and a member of the editorial board of Evolutionary Computation (published by MIT Press). He is also a member of the SIGEVO executive committee and he was named a Fellow of the International Society for Genetic and Evolutionary Computation. \n\nMore details: http://hampshire.edu/lspector Resume: http://hampshire.edu/lspector/spector-resume.pdf",meta:{duration:"PT40M8S"},presenter:{name:null},source:{id:"HWMJdO4klIE",provider:"youtube"},slug:"genetic-programming-in-clojure-lee-spector",tag:["clojure","Genetic Programming"],thumbnails:{default:{url:"https://i.ytimg.com/vi/HWMJdO4klIE/default.jpg",height:90,width:120}},title:"Genetic Programming in Clojure - Lee Spector"}},{node:{description:"Contemporary compilers are among the most complex of software systems, typically being required to handle sophisticated high-level source languages, generate efficient code for multiple hardware architectures and operating systems, and support source-level debuggers, profilers, and other program development tools. Nanopass frameworks are designed to help manage this complexity. A nanopass compiler is comprised of many single-task passes with formally defined intermediate languages. The nanopass compiler technique evolved from a methodology for teaching a compiler course at Indiana University, into a full-fledged framework, capable of implementing a replacement for the Chez Scheme compiler that runs on par with the original compiler. This talk will discuss the idea of a nanopass compiler and the implementation of a simple language using the framework in Chez Scheme, along with the challenges and opportunities of using these techniques in Clojure.\n\nAndy is a postdoc at the University of Utah, currently working on malware detection in Android Apps, using both Scala and miniKanren to write abstract analyzers in Matt Might's lab. Andy completed his Ph.D. at Indiana University, defending his dissertation, \"A Nanopass Framework for Commercial Compiler Development\", in December 2012 and will be presenting a paper related to this work at this year's International Conference on Functional Programming. This project focused on replacing Chez Scheme's compiler with a nanopass compiler, along with his adviser R. Kent Dybvig. Before returning to graduate school in 2007, Andy worked in industry as a web developer, first for the consulting firms Razorfish and Gotham Broadband, along with some independent consulting work for Viacom, and later worked full time at Teach For America, maintaining both front-end and back-end web applications.",meta:{duration:"PT40M48S"},presenter:{name:null},source:{id:"Os7FE3J-U5Q",provider:"youtube"},slug:"andy-keep-writing-a-nanopass-compiler",tag:["clojure"],thumbnails:{default:{url:"https://i.ytimg.com/vi/Os7FE3J-U5Q/default.jpg",height:90,width:120}},title:"Andy Keep - Writing a Nanopass Compiler"}},{node:{description:"This presentation will introduce a new start-up focused on machine learning that is using Clojure. We will discuss the technology and architecture it has developed for real-time machine learning and pattern recognition, and how Clojure provides a unique set of advantages.\n\nThere will be a live coding demonstration of interactively applying machine learning to a simple task and visualization of the results.",meta:{duration:"PT27M38S"},presenter:{name:null},source:{id:"QJ1qgCr09j8",provider:"youtube"},slug:"machine-learning-live-mike-anderson",tag:["clojure"],thumbnails:{default:{url:"https://i.ytimg.com/vi/QJ1qgCr09j8/default.jpg",height:90,width:120}},title:"Machine Learning Live - Mike Anderson"}},{node:{description:"Data science / big data exists at the overlap of traditional analytics and large scale computation. As such, neither the traditional tools of analytics (R, Mathematica, Matlab) nor mainstreams languages (Java, C++, C#) supply its requirements well as they cannot simultaneously provide the mathematical abstractions and real-word platform power that are required. Clojure is privileged in that it has the potential to provide just exactly that. This talk will explore why this is the case, the tools that are available and the challenges that need be overcome for Clojure to realise this potential.",meta:{duration:"PT32M40S"},presenter:{name:null},source:{id:"RVmY2lQ4DHE",provider:"youtube"},slug:"clojure-data-science-edmund-jackson",tag:["clojure"],thumbnails:{default:{url:"https://i.ytimg.com/vi/RVmY2lQ4DHE/default.jpg",height:90,width:120}},title:"Clojure Data Science - Edmund Jackson"}},{node:{description:"For most of human history, furniture was built by hand using a small set of simple tools. This approach connects you in a profoundly direct way to the work, your effort to the result. This changed with the rise of machine tools, which made production more efficient but also altered what's made and how we think about making it in in a profound way. This talk explores the effects of automation on our work, which is as relevant to software as it is to furniture, especially now that once again, with Clojure, we are building things using a small set of simple tools.\n\nTim Ewald designs and builds software systems. After 20 years using object oriented languages, he embraces Clojure because it provides the closes connection to the work and most directly expresses his intent. Tim works on the Datomic team at Cognitect, where he is a Vice President.",meta:{duration:"PT58M39S"},presenter:{name:null},source:{id:"ShEez0JkOFw",provider:"youtube"},slug:"tim-ewald-clojure-programming-with-hand-tools",tag:["clojure"],thumbnails:{default:{url:"https://i.ytimg.com/vi/ShEez0JkOFw/default.jpg",height:90,width:120}},title:"Tim Ewald - Clojure: Programming with Hand Tools"}},{node:{description:"Variants are Not Unions\n\nSome of the most confounding design problems occur when a value can be more than one type of thing. Variants, a.k.a. tagged unions, are an elegant solution to this problem that is not supported in an obvious way in Clojure and is not supported in most mainstream languages or databases. I'll demonstrate how and when to use tagged unions in Clojure, including a pattern-matching destructor and use with core.typed and storage in Datomic.",meta:{duration:"PT37M54S"},presenter:{name:null},source:{id:"ZQkIWWTygio",provider:"youtube"},slug:"jeanine-adkisson-variants-are-not-unions",tag:["clojure"],thumbnails:{default:{url:"https://i.ytimg.com/vi/ZQkIWWTygio/default.jpg",height:90,width:120}},title:"Jeanine Adkisson - Variants are Not Unions"}},{node:{description:"Clojure for a desktop GUI application. With JavaFX. For game development. And it's all built on top of an in-memory, transactional graph database.\n\nOne of the biggest game developers in the world needed a new IDE to build games for their engine. Eclipse just wasn't cutting it any more.\n\nIt may sound a bit nuts to use Clojure for desktop GUIs, but this architecture delivers incredible benefits to the tool developers.\n\nAbout the speakers: You can find Michael Nygard coding, writing, speaking, or thinking about how the Universe works. He has lived with systems in production and learned hard lessons about the importance of operations. Highly-available, highly-scalable commerce systems are his forte.\n\nRagnar Svensson has worked as a game developer for many years, starting out with player mechanics for AAA console games and transitioning into game engine programming, primarily for the mobile and web platforms. He co-founded the game engine Defold, which was acquired by King in 2014. He currently works for King as lead engine developer of the Defold engine.",meta:{duration:"PT35M10S"},presenter:{name:null},source:{id:"ajX09xQ_UEg",provider:"youtube"},slug:"game-development-development-michael-nygard-and-ragnar-svensson",tag:["clojure","Video Game Development (Conference Subject)"],thumbnails:{default:{url:"https://i.ytimg.com/vi/ajX09xQ_UEg/default.jpg",height:90,width:120}},title:"Game Development Development - Michael Nygard & Ragnar Svensson"}}]}},pathContext:{slug:"debugging-with-the-scientific-method-stuart-halloway",tags:["clojure","Debugging (Quotation Subject)","Scientific Method (Literature Subject)"]}}}});
//# sourceMappingURL=path---talk-debugging-with-the-scientific-method-stuart-halloway-1f8838343dc9b2788db0.js.map